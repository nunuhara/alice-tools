
int test_g;

interface IShopButton {
	void Update(void);
	void SetPos(int x, int y);
};

struct CustomButton : IShopButton {
	void Update(void) {
		test_g = 42;
	}
	void SetPos(int x, int y) {
	}
	~CustomButton() {
		test_g = 0;
	}
};

IShopButton ret_iface(void)
{
	return new CustomButton();
}

void test_interface(void)
{
	{
		IShopButton p = ret_iface();
		p.Update();
		assert(test_g == 42);
	}
	assert(test_g == 0);
}

option<int> ret_option(int a)
{
	if (a)
		return Option::Some(a);
	return Option::None;
}

void test_option(void)
{
	option<int> opt_some = ret_option(1);
	option<int> opt_none = ret_option(0);
	assert(opt_some.IsSome());
	assert(opt_none.IsNone());
	assert(opt_some.Value(2) == 1);
	assert(opt_none.Value(2) == 2);
}

TeachingItemType ret_enum_arg(TeachingItemType e)
{
	if (e == TeachingItemType::Invalid)
		return TeachingItemType::Looks;
	return e;
}

enum NewEnum {
	None = -1,
	ValA = 0,
	ValB = 1,
};

extend enum SkillType {
	NewVal = 3,
};

void test_enum(void)
{
	TeachingItemType e;
	assert(e == TeachingItemType::Invalid);
	assert(e != TeachingItemType::Looks);
	assert(ret_enum_arg(e) == TeachingItemType::Looks);
	assert((int)e == 0);
	assert((string)e == "Invalid");
	assert(TeachingItemType::Parse#1(1).Value(TeachingItemType::Invalid) == TeachingItemType::Looks);
	assert(TeachingItemType::Parse("Looks").Value(TeachingItemType::Invalid) == TeachingItemType::Looks);

	NewEnum e2;
	assert(e2 == NewEnum::None);
	assert(e2 != NewEnum::ValA);
	e2 = NewEnum::ValA;
	assert(e2 == NewEnum::ValA);
	assert(NewEnum::Parse#1(-1).Value(NewEnum::ValA) == NewEnum::None);
	assert(NewEnum::Parse#1(0).Value(NewEnum::None) == NewEnum::ValA);
	assert(NewEnum::Parse#1(1).Value(NewEnum::None) == NewEnum::ValB);
	assert(NewEnum::Parse("None").Value(NewEnum::ValA) == NewEnum::None);
	assert(NewEnum::Parse("ValA").Value(NewEnum::None) == NewEnum::ValA);
	assert(NewEnum::Parse("ValB").Value(NewEnum::None) == NewEnum::ValB);
	assert((string)NewEnum::None == "None");
	assert((string)NewEnum::ValA == "ValA");
	assert((string)NewEnum::ValB == "ValB");
	assert((int)NewEnum::None == -1);
	assert((int)NewEnum::ValA == 0);
	assert((int)NewEnum::ValB == 1);
	array<NewEnum> a = NewEnum::GetList();
	assert(a.Numof() == 3);
	assert(a[0] == NewEnum::None);
	assert(a[1] == NewEnum::ValA);
	assert(a[2] == NewEnum::ValB);
	assert(NewEnum::IsExist(-1));
	assert(NewEnum::IsExist(0));
	assert(NewEnum::IsExist(1));
	assert(NewEnum::Numof() == 3);

	assert(SkillType::Parse#1(0).Value(SkillType::Buffer) == SkillType::Attack);
	assert(SkillType::Parse#1(1).Value(SkillType::Attack) == SkillType::Buffer);
	assert(SkillType::Parse#1(2).Value(SkillType::Attack) == SkillType::Debuf);
	assert(SkillType::Parse#1(3).Value(SkillType::Attack) == SkillType::NewVal);
	assert(SkillType::Parse("Attack").Value(SkillType::Buffer) == SkillType::Attack);
	assert(SkillType::Parse("Buffer").Value(SkillType::Attack) == SkillType::Buffer);
	assert(SkillType::Parse("Debuf").Value(SkillType::Attack) == SkillType::Debuf);
	assert(SkillType::Parse("NewVal").Value(SkillType::Attack) == SkillType::NewVal);
	assert((string)SkillType::Attack == "Attack");
	assert((string)SkillType::Buffer == "Buffer");
	assert((string)SkillType::Debuf == "Debuf");
	assert((string)SkillType::NewVal == "NewVal");
	assert((int)SkillType::Attack == 0);
	assert((int)SkillType::Buffer == 1);
	assert((int)SkillType::Debuf == 2);
	assert((int)SkillType::NewVal == 3);
	array<SkillType> a2 = SkillType::GetList();
	assert(a2.Numof() == 4);
	assert(a2[0] == SkillType::Attack);
	assert(a2[1] == SkillType::Buffer);
	assert(a2[2] == SkillType::Debuf);
	assert(a2[3] == SkillType::NewVal);
	assert(SkillType::Numof() == 4);
}

override int main(void)
{
	test_interface();
	test_option();
	test_enum();
	//test_delegate(); // FIXME
	return super();
}
