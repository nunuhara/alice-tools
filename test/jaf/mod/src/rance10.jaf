
interface ISkillEffectProcess {
	bool Evaluate(void);
	void Process(void);
	ref BattleLog GetLog(void);
	int Type_get(void);
	int Type_get2(void);
};

int test_g;

struct CustomSkillEffectProcess : ISkillEffectProcess {
	bool Evaluate(void) {
		test_g = 42;
		return true;
	}
	void Process(void) {
	}
	ref BattleLog GetLog(void) {
		return NULL;
	}
	int Type_get(void) {
		return 0;
	}
	int Type_get2(void) {
		return 0;
	}
	~CustomSkillEffectProcess() {
		test_g = 0;
	}
};

ISkillEffectProcess ret_iface(void)
{
	return new CustomSkillEffectProcess();
}

void test_interface(void)
{
	{
		ISkillEffectProcess p = ret_iface();
		assert(p.Evaluate());
		assert(test_g == 42);
	}
	assert(test_g == 0);
}

option<int> ret_option(int a)
{
	if (a)
		return Option::Some(a);
	return Option::None;
}

void test_option(void)
{
	// XXX: option variables are not allowed in ain v12...
	assert(ret_option(1).IsSome());
	assert(ret_option(0).IsNone());
	assert(ret_option(1).Value(2) == 1);
	assert(ret_option(0).Value(2) == 2);
}

BadConditionType ret_enum_arg(BadConditionType e)
{
	if (e == BadConditionType::None)
		return BadConditionType::Sleep;
	return e;
}

enum NewEnum {
	None = -1,
	ValA = 0,
	ValB = 1,
};

void test_enum(void)
{
	BadConditionType e;
	assert(e == BadConditionType::None);
	assert(e != BadConditionType::Sleep);
	assert(ret_enum_arg(e) == BadConditionType::Sleep);
	assert((int)e == -1);
	assert((string)e == "None");
	assert(BadConditionType::Parse#1(7).Value(BadConditionType::None) == BadConditionType::Sleep);
	assert(BadConditionType::Parse("Sleep").Value(BadConditionType::None) == BadConditionType::Sleep);

	NewEnum e2;
	assert(e2 == NewEnum::None);
	assert(e2 != NewEnum::ValA);
	e2 = NewEnum::ValA;
	assert(e2 == NewEnum::ValA);
	assert(NewEnum::Parse#1(-1).Value(NewEnum::ValA) == NewEnum::None);
	assert(NewEnum::Parse#1(0).Value(NewEnum::None) == NewEnum::ValA);
	assert(NewEnum::Parse#1(1).Value(NewEnum::None) == NewEnum::ValB);
	assert(NewEnum::Parse("None").Value(NewEnum::ValA) == NewEnum::None);
	assert(NewEnum::Parse("ValA").Value(NewEnum::None) == NewEnum::ValA);
	assert(NewEnum::Parse("ValB").Value(NewEnum::None) == NewEnum::ValB);
	assert((string)NewEnum::None == "None");
	assert((string)NewEnum::ValA == "ValA");
	assert((string)NewEnum::ValB == "ValB");
	assert((int)NewEnum::None == -1);
	assert((int)NewEnum::ValA == 0);
	assert((int)NewEnum::ValB == 1);
	array<NewEnum> a = NewEnum::GetList();
	assert(a.Numof() == 3);
	assert(a[0] == NewEnum::None);
	assert(a[1] == NewEnum::ValA);
	assert(a[2] == NewEnum::ValB);
	assert(NewEnum::IsExist(-1));
	assert(NewEnum::IsExist(0));
	assert(NewEnum::IsExist(1));
	assert(NewEnum::NumOf() == 3);
}

override int main(void)
{
	//CrayfishLogViewer.OpenViewer();
	test_interface();
	test_option();
	test_enum();
	return super();
}
