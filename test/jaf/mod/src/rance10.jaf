
interface ISkillEffectProcess {
	bool Evaluate(void);
	void Process(void);
	ref BattleLog GetLog(void);
	int Type_get(void);
	int Type_get2(void);
};

int test_g;

struct CustomSkillEffectProcess : ISkillEffectProcess {
	bool Evaluate(void) {
		test_g = 42;
		return true;
	}
	void Process(void) {
	}
	ref BattleLog GetLog(void) {
		return NULL;
	}
	int Type_get(void) {
		return 0;
	}
	int Type_get2(void) {
		return 0;
	}
	~CustomSkillEffectProcess() {
		test_g = 0;
	}
};

ISkillEffectProcess ret_iface(void)
{
	return new CustomSkillEffectProcess();
}

void test_interface(void)
{
	{
		ISkillEffectProcess p = ret_iface();
		assert(p.Evaluate());
		assert(test_g == 42);
	}
	assert(test_g == 0);
}

option<int> ret_option(int a)
{
	if (a)
		return Option::Some(a);
	return Option::None;
}

void test_option(void)
{
	// XXX: option variables are not allowed in ain v12...
	assert(ret_option(1).IsSome());
	assert(ret_option(0).IsNone());
	assert(ret_option(1).Value(2) == 1);
	assert(ret_option(0).Value(2) == 2);
}

BadConditionType ret_enum_arg(BadConditionType e)
{
	if (e == BadConditionType::None)
		return BadConditionType::Sleep;
	return e;
}

void test_enum(void)
{
	BadConditionType e;
	assert(e == BadConditionType::None);
	assert(e != BadConditionType::Sleep);
	assert(ret_enum_arg(e) == BadConditionType::Sleep);
	assert((int)e == -1);
	assert((string)e == "None");
	assert(BadConditionType::Parse#1(7).Value(BadConditionType::None) == BadConditionType::Sleep);
	assert(BadConditionType::Parse("Sleep").Value(BadConditionType::None) == BadConditionType::Sleep);
}

override int main(void)
{
	test_interface();
	test_option();
	test_enum();
	return super();
}
